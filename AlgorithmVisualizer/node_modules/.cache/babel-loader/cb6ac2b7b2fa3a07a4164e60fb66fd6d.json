{"ast":null,"code":"export function getMergeSortAnimation(array) {\n  let animation = [];\n  let auxillaryarray = array.slice(); // MergeSort(auxillaryarray,0,auxillaryarray.length-1,animation);\n\n  [auxillaryarray, animation] = mergeSort(auxillaryarray, animation);\n  array = auxillaryarray;\n  console.log(auxillaryarray);\n  return [animation, array];\n}\n\nfunction mergeSort(unsortedArray, animation) {\n  // No need to sort the array if the array only has one element or empty\n  if (unsortedArray.length <= 1) {\n    return unsortedArray;\n  } // In order to divide the array in half, we need to figure out the middle\n\n\n  const middle = Math.floor(unsortedArray.length / 2); // This is where we will be dividing the array into left and right\n\n  const left = unsortedArray.slice(0, middle);\n  const right = unsortedArray.slice(middle); // Using recursion to combine the left and right\n\n  return merge(mergeSort(left), mergeSort(right), animation);\n}\n\nfunction merge(left, right, animation) {\n  let resultArray = [],\n      leftIndex = 0,\n      rightIndex = 0,\n      sortedIndex = 0; // We will concatenate values into the resultArray in order\n\n  while (leftIndex < left.length && rightIndex < right.length) {\n    animation.push([\"comparison1\", leftIndex, rightIndex + Math.floor((left.length + right.length) / 2)]);\n    animation.push([\"comparison2\", leftIndex, rightIndex + Math.floor((left.length + right.length) / 2)]);\n\n    if (left[leftIndex] < right[rightIndex]) {\n      animation.push([\"overwrite\", sortedIndex, left[leftIndex]]);\n      resultArray.push(left[leftIndex]);\n      leftIndex++; // move left array cursor\n    } else {\n      animation.push([\"overwrite\", sortedIndex, right[rightIndex]]);\n      resultArray.push(right[rightIndex]);\n      rightIndex++; // move right array cursor\n    }\n\n    sortedIndex++;\n  } // We need to concat here because there will be one element remaining\n  // from either left OR the right\n\n\n  return resultArray.concat(left.slice(leftIndex)).concat(right.slice(rightIndex));\n}","map":{"version":3,"sources":["/home/prajjawal-banati/COLLEGE/SEM VII/interactive-algorithm-visualizer/src/sortingAlgorithms/MergeSort.js"],"names":["getMergeSortAnimation","array","animation","auxillaryarray","slice","mergeSort","console","log","unsortedArray","length","middle","Math","floor","left","right","merge","resultArray","leftIndex","rightIndex","sortedIndex","push","concat"],"mappings":"AAAA,OAAO,SAASA,qBAAT,CAA+BC,KAA/B,EACP;AACI,MAAIC,SAAS,GAAC,EAAd;AACA,MAAIC,cAAc,GAACF,KAAK,CAACG,KAAN,EAAnB,CAFJ,CAGI;;AACA,GAACD,cAAD,EAAgBD,SAAhB,IAA2BG,SAAS,CAACF,cAAD,EAAgBD,SAAhB,CAApC;AACAD,EAAAA,KAAK,GAACE,cAAN;AACAG,EAAAA,OAAO,CAACC,GAAR,CAAYJ,cAAZ;AACA,SAAO,CAACD,SAAD,EAAWD,KAAX,CAAP;AACH;;AACD,SAASI,SAAT,CAAoBG,aAApB,EAAkCN,SAAlC,EAA6C;AACzC;AACA,MAAIM,aAAa,CAACC,MAAd,IAAwB,CAA5B,EAA+B;AAC7B,WAAOD,aAAP;AACD,GAJwC,CAKzC;;;AACA,QAAME,MAAM,GAAGC,IAAI,CAACC,KAAL,CAAWJ,aAAa,CAACC,MAAd,GAAuB,CAAlC,CAAf,CANyC,CAQzC;;AACA,QAAMI,IAAI,GAAGL,aAAa,CAACJ,KAAd,CAAoB,CAApB,EAAuBM,MAAvB,CAAb;AACA,QAAMI,KAAK,GAAGN,aAAa,CAACJ,KAAd,CAAoBM,MAApB,CAAd,CAVyC,CAYzC;;AACA,SAAOK,KAAK,CACVV,SAAS,CAACQ,IAAD,CADC,EACOR,SAAS,CAACS,KAAD,CADhB,EACwBZ,SADxB,CAAZ;AAGD;;AACD,SAASa,KAAT,CAAgBF,IAAhB,EAAsBC,KAAtB,EAA4BZ,SAA5B,EAAuC;AACrC,MAAIc,WAAW,GAAG,EAAlB;AAAA,MAAsBC,SAAS,GAAG,CAAlC;AAAA,MAAqCC,UAAU,GAAG,CAAlD;AAAA,MAAqDC,WAAW,GAAC,CAAjE,CADqC,CAGrC;;AACA,SAAOF,SAAS,GAAGJ,IAAI,CAACJ,MAAjB,IAA2BS,UAAU,GAAGJ,KAAK,CAACL,MAArD,EAA6D;AACzDP,IAAAA,SAAS,CAACkB,IAAV,CAAe,CAAC,aAAD,EAAeH,SAAf,EAAyBC,UAAU,GAACP,IAAI,CAACC,KAAL,CAAW,CAACC,IAAI,CAACJ,MAAL,GAAYK,KAAK,CAACL,MAAnB,IAA2B,CAAtC,CAApC,CAAf;AACAP,IAAAA,SAAS,CAACkB,IAAV,CAAe,CAAC,aAAD,EAAeH,SAAf,EAAyBC,UAAU,GAACP,IAAI,CAACC,KAAL,CAAW,CAACC,IAAI,CAACJ,MAAL,GAAYK,KAAK,CAACL,MAAnB,IAA2B,CAAtC,CAApC,CAAf;;AACF,QAAII,IAAI,CAACI,SAAD,CAAJ,GAAkBH,KAAK,CAACI,UAAD,CAA3B,EAAyC;AACvChB,MAAAA,SAAS,CAACkB,IAAV,CAAe,CAAC,WAAD,EAAaD,WAAb,EAAyBN,IAAI,CAACI,SAAD,CAA7B,CAAf;AACAD,MAAAA,WAAW,CAACI,IAAZ,CAAiBP,IAAI,CAACI,SAAD,CAArB;AACAA,MAAAA,SAAS,GAH8B,CAG1B;AACd,KAJD,MAIO;AACLf,MAAAA,SAAS,CAACkB,IAAV,CAAe,CAAC,WAAD,EAAaD,WAAb,EAAyBL,KAAK,CAACI,UAAD,CAA9B,CAAf;AACAF,MAAAA,WAAW,CAACI,IAAZ,CAAiBN,KAAK,CAACI,UAAD,CAAtB;AACAA,MAAAA,UAAU,GAHL,CAGS;AACf;;AACDC,IAAAA,WAAW;AACZ,GAjBoC,CAmBrC;AACA;;;AACA,SAAOH,WAAW,CACTK,MADF,CACSR,IAAI,CAACT,KAAL,CAAWa,SAAX,CADT,EAEEI,MAFF,CAESP,KAAK,CAACV,KAAN,CAAYc,UAAZ,CAFT,CAAP;AAGD","sourcesContent":["export function getMergeSortAnimation(array)\n{\n    let animation=[];\n    let auxillaryarray=array.slice();\n    // MergeSort(auxillaryarray,0,auxillaryarray.length-1,animation);\n    [auxillaryarray,animation]=mergeSort(auxillaryarray,animation);\n    array=auxillaryarray;\n    console.log(auxillaryarray);\n    return [animation,array];\n}\nfunction mergeSort (unsortedArray,animation) {\n    // No need to sort the array if the array only has one element or empty\n    if (unsortedArray.length <= 1) {\n      return unsortedArray;\n    }\n    // In order to divide the array in half, we need to figure out the middle\n    const middle = Math.floor(unsortedArray.length / 2);\n  \n    // This is where we will be dividing the array into left and right\n    const left = unsortedArray.slice(0, middle);\n    const right = unsortedArray.slice(middle);\n  \n    // Using recursion to combine the left and right\n    return merge(\n      mergeSort(left), mergeSort(right),animation\n    );\n  }\n  function merge (left, right,animation) {\n    let resultArray = [], leftIndex = 0, rightIndex = 0, sortedIndex=0;\n  \n    // We will concatenate values into the resultArray in order\n    while (leftIndex < left.length && rightIndex < right.length) {\n        animation.push([\"comparison1\",leftIndex,rightIndex+Math.floor((left.length+right.length)/2)])\n        animation.push([\"comparison2\",leftIndex,rightIndex+Math.floor((left.length+right.length)/2)])\n      if (left[leftIndex] < right[rightIndex]) {\n        animation.push([\"overwrite\",sortedIndex,left[leftIndex]])\n        resultArray.push(left[leftIndex]);\n        leftIndex++; // move left array cursor\n      } else {\n        animation.push([\"overwrite\",sortedIndex,right[rightIndex]]);\n        resultArray.push(right[rightIndex]);\n        rightIndex++; // move right array cursor\n      }\n      sortedIndex++;\n    }\n  \n    // We need to concat here because there will be one element remaining\n    // from either left OR the right\n    return resultArray\n            .concat(left.slice(leftIndex))\n            .concat(right.slice(rightIndex));\n  }"]},"metadata":{},"sourceType":"module"}