{"version":3,"sources":["sortingAlgorithms/MergeSort.js","SortingVisualizer/SortingVisualizer.jsx","sortingAlgorithms/BubbleSort.js","sortingAlgorithms/SelectionSort.js","sortingAlgorithms/InsertionSort.js","searchingAlgorithms/BinarySearch.js","SearchingVisualizer/SearchingVisualizer.jsx","searchingAlgorithms/LinearSearch.js","PathfindingVisualizer/Node/Node.jsx","Pathfindingalgorithms/dijkstra.js","PathfindingVisualizer/PathfindingVisualizer.jsx","Pathfindingalgorithms/bfs.js","Pathfindingalgorithms/dfs.js","App.js","serviceWorker.js","index.js"],"names":["getMergeSortAnimation","array","animation","auxillaryarray","slice","mergeSort","length","unsortedArray","forwardindex","endingindex","middleindex","Math","floor","startindex","SortedArray","i","j","push","merge","PRIMARY_COLOR","SECONDARY_COLOR","SortingVisualizer","props","state","this","resetArray","min","max","random","setState","iterator","swapped","temp","bubblesort","getbubblesortanimation","animations","iscolorchange","arraybars","document","getElementsByClassName","color","barOneIndex","barTwoIndex","FirstBarStyle","style","SecondBarStyle","setTimeout","backgroundColor","barIndex","newHeight","barStyle","height","console","log","min_idx","SelectionSort","getSelectionSortAnimation","auxilliaryarray","key","InsertionSort","getInsertionSortAnimation","className","onClick","BubbleSort","MergeSort","map","value","idx","React","Component","getBinarySearchAnimations","number","BinarySearch","starting","ending","midindex","ANIMATION_SPEED_MS","FOUND_COLOR","handleChange","bind","event","target","sort","a","b","element","parseInt","LinearSearch","getLinearSearchAnimations","arrayboxes","barindex","barFoundIndex","barstyle","alert","onebarindex","secondbarindex","type","name","onChange","placeholder","autoComplete","for","Node","col","isFinish","isStart","isWall","onMouseDown","onMouseEnter","onMouseUp","row","extraClassName","id","dijkstra","grid","startNode","finishNode","visitedNodesInOrder","distance","unvisitedNodes","nodes","node","getAllNodes","sortNodesByDistance","closestNode","shift","Infinity","isVisited","updateUnvisitedNeighbors","nodeA","nodeB","unvisitedNeighbors","neighbors","filter","neighbor","getUnvisitedNeighbors","previousNode","PathfindingVisualizer","getInitialGrid","rowCount","ROW_COUNT","colCount","COLUMN_COUNT","initialGrid","currentRow","createNode","START_NODE_ROW","START_NODE_COL","FINISH_NODE_ROW","FINISH_NODE_COL","distanceToFinishNode","abs","isNode","mouseIsPressed","MOBILE_ROW_COUNT","MOBILE_COLUMN_COUNT","isRunning","isStartNode","isFinishNode","isWallNode","currRow","currCol","isDesktopView","handleMouseDown","handleMouseLeave","toggleIsRunning","clearGrid","clearWalls","isGridClear","getElementById","newGrid","getNewGridWithWallToggled","nodeClassName","algo","nextNodesStack","currentNode","nextNode","bfs","pop","dfs","nodesInShortestPathOrder","unshift","getNodesInShortestPathOrder","animate","animateShortestPath","visualize","onMouseLeave","rowIdx","nodeIdx","handleMouseEnter","handleMouseUp","newNode","App","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.cf6ab0b9.chunk.js","sourcesContent":["export function getMergeSortAnimation(array)\n{\n  let animation=[];\n  let auxillaryarray=array.slice();\n  mergeSort(auxillaryarray,0,auxillaryarray.length-1,animation);\n  return [animation,array];\n}\nfunction mergeSort (unsortedArray,forwardindex,endingindex,animation) {\n  if(forwardindex==endingindex)\n  {\n    return;\n  }\n  let middleindex=Math.floor((forwardindex+endingindex)/2);\n  mergeSort(unsortedArray,forwardindex,middleindex,animation);\n  mergeSort(unsortedArray,middleindex+1,endingindex,animation);\n  merge(unsortedArray,forwardindex,middleindex,endingindex,animation);\n}\nfunction merge(unsortedArray,startindex,middleindex,endingindex,animation)\n{\n  let SortedArray=[];\n  let i=startindex;\n  let j=middleindex+1;\n  while(i<=middleindex && j <= endingindex)\n  {\n    animation.push([\"comparison1\",i,j]);\n    animation.push([\"comparison2\",i,j]);\n    if(unsortedArray[i]<=unsortedArray[j])\n    {\n      SortedArray.push(unsortedArray[i++]);\n    }\n    else {\n      SortedArray.push(unsortedArray[j++]);\n    }\n  }\n  while (i<=middleindex)\n  {\n    animation.push([\"comparison1\",i,i]);\n    animation.push([\"comparison2\",i,i]);\n    SortedArray.push(unsortedArray[i++]);\n  }\n  while(j<=endingindex)\n  {\n    animation.push([\"comparison1\",j,j]);\n    animation.push([\"comparison2\",j,j]);\n    SortedArray.push(unsortedArray[j++]);\n  }\n  for(let i=startindex;i<=endingindex;i++)\n  {\n    animation.push([\"comparison1\",i,i-startindex])\n    animation.push([\"swap\",i,SortedArray[i-startindex]]);\n    animation.push([\"comparison2\",i,i-startindex]);\n    unsortedArray[i]=SortedArray[i-startindex];\n  }\n}","import React from 'react';\nimport {getbubblesortanimation} from '../sortingAlgorithms/BubbleSort';\nimport {getSelectionSortAnimation} from '../sortingAlgorithms/SelectionSort';\nimport {getInsertionSortAnimation} from '../sortingAlgorithms/InsertionSort';\nimport {getMergeSortAnimation} from '../sortingAlgorithms/MergeSort';\nimport './SortingVisualizer.css';\n\n// Change this value for the speed of the animations.\nconst ANIMATION_SPEED_MS = 1;\n\n// Change this value for the number of bars (value) in the array.\nconst NUMBER_OF_ARRAY_BARS = 310;\n\n// This is the main color of the array bars.\nconst PRIMARY_COLOR = 'orange';\n\n// This is the color of array bars that are being compared throughout the animations.\nconst SECONDARY_COLOR = 'black';\n\nexport default class SortingVisualizer extends React.Component{\n    constructor(props){\n        super (props);\n        this.state = {\n            array: [],\n        };\n    }\n    componentDidMount(){\n        this.resetArray();\n    }\n    resetArray(){\n        const array = [];\n        for(let i=0;i<NUMBER_OF_ARRAY_BARS;i++)\n        {\n            array.push(randomIntFromInterval(5,730));\n        }\n        this.setState({array});\n    }\n    BubbleSort()\n    {\n        const [animations,sortedarray] = getbubblesortanimation(this.state.array);\n        for(let i=0;i<animations.length;++i)\n        {\n            const iscolorchange = animations[i][0] === \"comparison1\" || animations[i][0] === \"comparison2\";\n            // console.log(iscolorchange);\n            const arraybars = document.getElementsByClassName('array-bar');\n            if(iscolorchange === true)\n            {\n                const color = (animations[i][0] === \"comparison1\") ? SECONDARY_COLOR : PRIMARY_COLOR;\n                // console.log(color);\n                const [comparison,barOneIndex,barTwoIndex] = animations[i];\n                const FirstBarStyle = arraybars[barOneIndex].style;\n                const SecondBarStyle = arraybars[barTwoIndex].style;\n                setTimeout(() => {\n                    FirstBarStyle.backgroundColor = color;\n                    SecondBarStyle.backgroundColor = color;\n                },i * ANIMATION_SPEED_MS);\n            }\n            else {\n                const [swap, barIndex, newHeight] = animations[i];\n                if (barIndex === -1) {\n                    continue;\n                }\n                const barStyle = arraybars[barIndex].style;\n                setTimeout(() => {\n                    barStyle.height = `${newHeight}px`;\n                },i * ANIMATION_SPEED_MS); \n            }\n        }\n    }\n    SelectionSort()\n    {\n        const[animations,sortedarray]=getSelectionSortAnimation(this.state.array);\n        // console.log(sortedarray);\n        for(let i=0;i<animations.length;++i)\n        {\n            const iscolorchange = animations[i][0] === \"comparison1\" || animations[i][0] === \"comparison2\";\n            // console.log(iscolorchange);\n            const arraybars = document.getElementsByClassName('array-bar');\n            if(iscolorchange === true)\n            {\n                const color = (animations[i][0] === \"comparison1\") ? SECONDARY_COLOR : PRIMARY_COLOR;\n                // console.log(color);\n                const [comparison,barOneIndex,barTwoIndex] = animations[i];\n                const FirstBarStyle = arraybars[barOneIndex].style;\n                const SecondBarStyle = arraybars[barTwoIndex].style;\n                setTimeout(() => {\n                    FirstBarStyle.backgroundColor = color;\n                    SecondBarStyle.backgroundColor = color;\n                },i * ANIMATION_SPEED_MS);\n            }\n            else {\n                const [swap, barIndex, newHeight] = animations[i];\n                if (barIndex === -1) {\n                    continue;\n                }\n                const barStyle = arraybars[barIndex].style;\n                setTimeout(() => {\n                    barStyle.height = `${newHeight}px`;\n                },i * ANIMATION_SPEED_MS); \n            }\n        }\n    }\n    InsertionSort()\n    {\n        const[animations,sortedarray]=getInsertionSortAnimation(this.state.array);\n        // console.log(sortedarray);\n        for(let i=0;i<animations.length;++i)\n        {\n            const iscolorchange = animations[i][0] === \"comparison1\" || animations[i][0] === \"comparison2\";\n            // console.log(iscolorchange);\n            const arraybars = document.getElementsByClassName('array-bar');\n            if(iscolorchange === true)\n            {\n                const color = (animations[i][0] === \"comparison1\") ? SECONDARY_COLOR : PRIMARY_COLOR;\n                // console.log(color);\n                const [comparison,barOneIndex,barTwoIndex] = animations[i];\n                const FirstBarStyle = arraybars[barOneIndex].style;\n                const SecondBarStyle = arraybars[barTwoIndex].style;\n                setTimeout(() => {\n                    FirstBarStyle.backgroundColor = color;\n                    SecondBarStyle.backgroundColor = color;\n                },i * ANIMATION_SPEED_MS);\n            }\n            else {\n                const [swap, barIndex, newHeight] = animations[i];\n                if (barIndex === -1) {\n                    continue;\n                }\n                const barStyle = arraybars[barIndex].style;\n                setTimeout(() => {\n                    barStyle.height = `${newHeight}px`;\n                },i * ANIMATION_SPEED_MS); \n            }\n        }\n    }\n    \n    MergeSort()\n    {\n        console.log(this.state.array);\n        const[animations,sortedarray]=getMergeSortAnimation(this.state.array);\n        // for(let i=0;i<animations.length;i++)\n        // {\n        //     console.log(animations[i]);\n        // }\n        //console.log(sortedarray);\n        for(let i=0;i<animations.length;++i)\n        {\n            const iscolorchange = animations[i][0] === \"comparison1\" || animations[i][0] === \"comparison2\";\n            // console.log(iscolorchange);\n            const arraybars = document.getElementsByClassName('array-bar');\n            if(iscolorchange === true)\n            {\n                const color = (animations[i][0] === \"comparison1\") ? SECONDARY_COLOR : PRIMARY_COLOR;\n                // console.log(color);\n                const [comparison,barOneIndex,barTwoIndex] = animations[i];\n                const FirstBarStyle = arraybars[barOneIndex].style;\n                const SecondBarStyle = arraybars[barTwoIndex].style;\n                setTimeout(() => {\n                    FirstBarStyle.backgroundColor = color;\n                    SecondBarStyle.backgroundColor = color;\n                },i * ANIMATION_SPEED_MS);\n            }\n            else {\n                const [swap, barIndex, newHeight] = animations[i];\n                if (barIndex === -1) {\n                    continue;\n                }\n                const barStyle = arraybars[barIndex].style;\n                setTimeout(() => {\n                    barStyle.height = `${newHeight}px`;\n                },i * ANIMATION_SPEED_MS); \n            }\n        }\n    }\n\n    QuickSort()\n    {\n\n    }\n\n    HeapSort()\n    {\n        \n    }\n\n    render(){\n        const {array} = this.state;\n        return (<div>\n        <div className = \"App-header\">\n        <div className = \"heading\">\n        <h2>Sorting Visualizer</h2>\n        </div>\n      <div className = \"button\" onClick={() => this.resetArray()}> Generate an Array </div>\n      <div className = \"button\" onClick={() => this.SelectionSort()}> Selection Sort </div>\n      <div className = \"button\" onClick={() => this.BubbleSort()}> Bubble Sort </div>\n      <div className = \"button\" onClick={() => this.InsertionSort()}> Insertion Sort </div>\n      <div className = \"button\" onClick={() => this.MergeSort()}> Merge Sort </div>\n      </div>\n        <div className =\"array-container\">\n            {array.map((value,idx) => (\n                <div\n                className = \"array-bar\"\n                key = {idx}\n                style = {{\n                    backgroundColor:PRIMARY_COLOR,\n                    height: `${value}px`,\n                }}></div>\n            ))\n            }\n        </div>\n        <div className=\"footer\">\n      </div>\n        </div>);\n    }\n}\nfunction randomIntFromInterval(min, max) {\n    // min and max included\n    return Math.floor(Math.random() * (max - min + 1) + min);\n  }","export function getbubblesortanimation(array)\n{\n    let animation=[];\n    let auxillaryarray=array.slice();\n    bubblesort(auxillaryarray,animation);\n    array = auxillaryarray;\n    return [animation,array];\n}\nfunction bubblesort(auxillaryarray,animation)\n{\n    const length = auxillaryarray.length;\n    let iterator = length-1;\n    while(iterator > 0)\n    {\n        let swapped = false;\n        for(let i = 0;i < iterator; i++)\n        {\n            animation.push([\"comparison1\",i,i+1]);\n            animation.push([\"comparison2\",i,i+1]);\n            if(auxillaryarray[i] > auxillaryarray[i+1])\n            {\n                swapped = true;\n                animation.push([\"swap\",i,auxillaryarray[i+1]]);\n                animation.push([\"swap\",i+1,auxillaryarray[i]]);\n                let temp = auxillaryarray[i];\n                auxillaryarray[i] = auxillaryarray[i+1];\n                auxillaryarray[i+1] = temp;\n            }\n        }\n        if(swapped === false) break;\n        iterator--;\n    }\n}","export function getSelectionSortAnimation(array)\n{\n    let animations=[];\n    let auxillaryarray=array.slice();\n    console.log(array)\n    SelectionSort(auxillaryarray,animations);\n    array=auxillaryarray;\n    console.log(auxillaryarray);\n    return [animations,array];\n}\nfunction SelectionSort(auxillaryarray,animations)\n{\n    for(let i=0;i<auxillaryarray.length;i++)\n    {\n        let element=auxillaryarray[i];\n        let min_idx=i;\n        for(let j=i+1;j<auxillaryarray.length;j++)\n        {\n            animations.push([\"comparison1\",min_idx,j]);\n            animations.push([\"comparison2\",min_idx,j]);\n            if(auxillaryarray[min_idx] > auxillaryarray[j])\n            {\n                min_idx=j;\n            }\n        }\n        animations.push([\"swap\",min_idx,auxillaryarray[i]]);\n        animations.push([\"swap\",i,auxillaryarray[min_idx]]);\n        let temp=auxillaryarray[min_idx];\n        auxillaryarray[min_idx]=auxillaryarray[i];\n        auxillaryarray[i]=temp;\n    }\n}","export function getInsertionSortAnimation(array)\n{\n    let animations=[];\n    let auxilliaryarray=[];\n    auxilliaryarray=array.slice();\n    InsertionSort(auxilliaryarray,animations);\n    array=auxilliaryarray;\n    return [animations,array];\n}\nfunction InsertionSort(auxilliaryarray,animations)\n{\n    for(let i=1;i<auxilliaryarray.length;i++)\n    {\n        let key=auxilliaryarray[i];\n        let j=i-1;\n        animations.push([\"comparison1\",i,j]);\n        animations.push([\"comparison2\",i,j]);\n        while(j>=0 && auxilliaryarray[j]>key)\n        {\n            animations.push([\"comparison1\",i,j]);\n            animations.push([\"comparison2\",i, j]);\n            auxilliaryarray[j+1]=auxilliaryarray[j];\n            animations.push([\"swap\",j+1,auxilliaryarray[j]]);\n            j--;\n        }\n        animations.push([\"swap\",j+1,key]);\n        auxilliaryarray[j+1]=key;\n    }\n}","export function getBinarySearchAnimations(array,number)\n{\n    let animations=[];\n    animations=BinarySearch(0,array.length-1,array,number,animations);\n    return animations;\n}\nfunction BinarySearch(starting,ending,array,number,animations)\n{\n    if(ending>=starting)\n    {\n        animations.push([\"iteration1\",starting,ending]);\n        animations.push([\"iteration2\",starting,ending]);\n        const midindex=Math.floor((starting+ending)/2);\n        if(array[midindex]===number)\n        {\n            animations.push([\"found\",midindex,midindex]);\n            return animations;\n        }\n        else if(array[midindex]>number)\n        {\n            ending=midindex-1;\n            return BinarySearch(starting,ending,array,number,animations);\n        }\n        else if(array[midindex]<number)\n        {\n            starting=midindex+1;\n            return BinarySearch(starting,ending,array,number, animations);\n        }\n    }\n    else{\n        animations.push([\"notfound\",-1,-1]);\n        return animations;\n    }\n\n}","import React from 'react';\nimport './styles.css';\nimport { getLinearSearchAnimations } from '../searchingAlgorithms/LinearSearch';\nimport { getBinarySearchAnimations } from '../searchingAlgorithms/BinarySearch';\n// Change this value for the speed of the animations.\nconst ANIMATION_SPEED_MS = 50;\n\n// Change this value for the number of bars (value) in the array.\nconst NUMBER_OF_ARRAY_BARS = 310;\n\n// This is the main color of the array bars.\nconst PRIMARY_COLOR = 'orange';\n\n// This is the color of array bars that are being compared throughout the animations.\nconst SECONDARY_COLOR = 'red';\n\nconst FOUND_COLOR = 'green'\n\nexport default class SortingVisualizer extends React.Component{\n    constructor(props){\n        super (props);\n        this.state = {\n            array: [],\n            value: ''\n        };\n        this.handleChange = this.handleChange.bind(this);\n    }\n    componentDidMount(){\n        this.resetArray();\n    }\n    handleChange(event)\n    {\n        this.setState({value: event.target.value});\n    }\n    resetArray(){\n        const array = [];\n        for(let i=0;i<NUMBER_OF_ARRAY_BARS;i++)\n        {\n            array.push(randomIntFromInterval(5,730));\n        }\n        array.sort((a,b)=>a - b);\n        this.setState({array});\n    }\n    LinearSearch()\n    {\n        if(this.state.value.length>0)\n        {\n\n            let element=parseInt(this.state.value);\n            const animations=getLinearSearchAnimations(this.state.array,element);\n            for(let i=0;i<animations.length;i++)\n            {\n                const iscolorchange = animations[i][0] === \"iteration1\" || animations[i][0] === \"iteration2\";\n                const arrayboxes = document.getElementsByClassName('array-bar-2');\n                if(iscolorchange===true)\n                {\n                    const color = (animations[i][0] === \"iteration1\") ? SECONDARY_COLOR:PRIMARY_COLOR;\n                    const barindex=animations[i][1];\n                    const FirstBarStyle=arrayboxes[barindex].style;\n                    setTimeout(()=>{\n                        FirstBarStyle.backgroundColor=color;\n                    },i*ANIMATION_SPEED_MS);\n                }\n                else if(animations[i][0]===\"found\") {\n                    const barFoundIndex=animations[i][1];\n                    const barstyle=arrayboxes[barFoundIndex].style;\n                    setTimeout(()=>{\n                        barstyle.backgroundColor=FOUND_COLOR;\n                    },i*ANIMATION_SPEED_MS);\n                    setTimeout(()=>{\n                        barstyle.backgroundColor=PRIMARY_COLOR;\n                    },(animations.length+50)*ANIMATION_SPEED_MS);\n                }\n                else {\n                    setTimeout(()=>{\n                        alert(\"Element Not Found\");\n                    },i*ANIMATION_SPEED_MS);\n                }\n            }\n        }\n        else{\n            alert(\"Enter the number to search\");\n        }\n        \n    }\n    BinarySearch()\n    {\n        if(this.state.value>0)\n        {\n            let element=parseInt(this.state.value);\n            const animations=getBinarySearchAnimations(this.state.array,element);\n            for(let i=0;i<animations.length;i++)\n            {\n                const iscolorchange = animations[i][0] === \"iteration1\" || animations[i][0] === \"iteration2\";\n                const arrayboxes = document.getElementsByClassName('array-bar-2');\n                if(iscolorchange===true)\n                {\n                    const color = (animations[i][0] === \"iteration1\") ? SECONDARY_COLOR:PRIMARY_COLOR;\n                    const onebarindex=animations[i][1];\n                    const secondbarindex=animations[i][2];\n                    const FirstBarStyle=arrayboxes[onebarindex].style;\n                    const SecondBarStyle=arrayboxes[secondbarindex].style;\n                    setTimeout(()=>{\n                        FirstBarStyle.backgroundColor=color;\n                        SecondBarStyle.backgroundColor=color;\n                    },i*ANIMATION_SPEED_MS);\n                }\n                else if(animations[i][0]===\"found\")\n                {\n                    const barFoundIndex=animations[i][1];\n                    const barstyle=arrayboxes[barFoundIndex].style;\n                    setTimeout(()=>{\n                        barstyle.backgroundColor=FOUND_COLOR;\n                    },i*ANIMATION_SPEED_MS);\n                    setTimeout(()=>{\n                        barstyle.backgroundColor=PRIMARY_COLOR;\n                    },(animations.length+50)*ANIMATION_SPEED_MS);\n                }\n                else{\n                    setTimeout(()=>{\n                        alert(\"Element Not Found\");\n                    },i*ANIMATION_SPEED_MS);\n                    \n                }\n            }\n        } \n        else{\n            alert(\"Enter the number to search\");\n        }       \n    }\n    JumpSearch()\n    {\n        let element=parseInt(this.state.value);\n        \n    }\n    ExponentialSearch()\n    {\n        let element = parseInt(this.state.value);\n        \n    }\n\n    render(){\n        const {array} = this.state;\n        return (<div>\n        <div className = \"App-header-2\">\n        <div className = \"heading\">\n        <h2>Searching Visualizer</h2>\n        </div>\n        <div className = \"inputnumber\"> <input type=\"text\" name=\"name\" className=\"element-input\" onChange={this.handleChange} placeholder=\"\" autoComplete=\"off\"/>\n        <label for=\"name\" className=\"element-label\">Number</label>\n        </div>\n        <div className = \"button\" onClick={() => this.resetArray()}> Generate an Array </div>\n        <div className = \"button\" onClick={() => this.LinearSearch()}> Linear Search </div>\n        <div className = \"button\" onClick={() => this.BinarySearch()}> Binary Search </div>\n        </div>\n        <div className =\"array-container-2\">\n            {array.map((value,idx) => (\n                <div\n                className = \"array-bar-2\"\n                key = {idx}\n                style = {{\n                    backgroundColor:PRIMARY_COLOR,\n                }}>\n                    {value}\n                </div>\n            ))\n            }\n        </div>\n        <div className=\"footer-2\">\n      </div>\n        </div>);\n    }\n}\nfunction randomIntFromInterval(min, max) {\n    // min and max included\n    return Math.floor(Math.random() * (max - min + 1) + min);\n  }","export function getLinearSearchAnimations(array,number)\n{\n    let animations=[];\n    animations=LinearSearch(array,number,animations);\n    return animations;\n}\nfunction LinearSearch(array, number,animations)\n{\n    for(let i=0;i<array.length;i++)\n    {\n        animations.push([\"iteration1\",i]);\n        animations.push([\"iteration2\",i]);\n        if(array[i]===number)\n        {\n            animations.push([\"found\",i])\n            return animations;\n        }\n    }\n    animations.push([\"notfound\",-1]);\n    return animations;\n}","import React, {Component} from 'react';\r\n\r\nimport './Node.css';\r\n\r\nexport default class Node extends Component {\r\n  render() {\r\n    const {\r\n      col,\r\n      isFinish,\r\n      isStart,\r\n      isWall,\r\n      onMouseDown,\r\n      onMouseEnter,\r\n      onMouseUp,\r\n      row,\r\n    } = this.props;\r\n    \r\n    const extraClassName = isFinish\r\n      ? 'node-finish'\r\n      : isStart\r\n      ? 'node-start'\r\n      : isWall\r\n      ? 'node-wall'\r\n      : '';\r\n\r\n    return (\r\n      <td\r\n        id={`node-${row}-${col}`}\r\n        className={`node ${extraClassName}`}\r\n        onMouseDown={() => onMouseDown(row, col)}\r\n        onMouseEnter={() => onMouseEnter(row, col)}\r\n        onMouseUp={() => onMouseUp()}></td>\r\n    );\r\n  }\r\n}\r\n","// Returns all nodes in the order in which they were visited.\r\n// Make nodes point back to their previous node so that we can compute the shortest path\r\n// by backtracking from the finish node.\r\n\r\nexport function dijkstra(grid, startNode, finishNode) {\r\n  const visitedNodesInOrder = [];\r\n  startNode.distance = 0;\r\n  const unvisitedNodes = getAllNodes(grid); // Q: different from using grid or slice of grid???\r\n\r\n  while (unvisitedNodes.length) {\r\n    sortNodesByDistance(unvisitedNodes);\r\n    const closestNode = unvisitedNodes.shift();\r\n    // If we encounter a wall, we skip it.\r\n    if (!closestNode.isWall) {\r\n      // If the closest node is at a distance of infinity,\r\n      // we must be trapped and should stop.\r\n      if (closestNode.distance === Infinity) return visitedNodesInOrder;\r\n      closestNode.isVisited = true;\r\n      visitedNodesInOrder.push(closestNode);\r\n      if (closestNode === finishNode) return visitedNodesInOrder;\r\n      updateUnvisitedNeighbors(closestNode, grid);\r\n    }\r\n  }\r\n  \r\n}\r\n\r\nfunction getAllNodes(grid) {\r\n  const nodes = [];\r\n  for (const row of grid) {\r\n    for (const node of row) {\r\n      nodes.push(node);\r\n    }\r\n  }\r\n  return nodes;\r\n}\r\n\r\nfunction sortNodesByDistance(unvisitedNodes) {\r\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n}\r\n\r\nfunction updateUnvisitedNeighbors(node, grid) {\r\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\r\n  for (const neighbor of unvisitedNeighbors) {\r\n    neighbor.distance = node.distance + 1;\r\n    neighbor.previousNode = node;\r\n  }\r\n}\r\n\r\nfunction getUnvisitedNeighbors(node, grid) {\r\n  const neighbors = [];\r\n  const {col, row} = node;\r\n  if (row > 0) neighbors.push(grid[row - 1][col]);\r\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n  if (col > 0) neighbors.push(grid[row][col - 1]);\r\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n  return neighbors.filter(neighbor => !neighbor.isVisited);\r\n}\r\n","import React, {Component} from 'react';\r\nimport Node from './Node/Node';\r\nimport {dijkstra} from '../Pathfindingalgorithms/dijkstra';\r\nimport {dfs} from '../Pathfindingalgorithms/dfs';\r\nimport {bfs} from '../Pathfindingalgorithms/bfs';\r\n\r\nimport './PathfindingVisualizer.css';\r\n\r\nexport default class PathfindingVisualizer extends Component {\r\n  constructor() {\r\n    super();\r\n    this.state = {\r\n      grid: [],\r\n      START_NODE_ROW: 5,\r\n      FINISH_NODE_ROW: 5,\r\n      START_NODE_COL: 5,\r\n      FINISH_NODE_COL: 15,\r\n      mouseIsPressed: false,\r\n      ROW_COUNT: 25,\r\n      COLUMN_COUNT: 35,\r\n      MOBILE_ROW_COUNT: 10,\r\n      MOBILE_COLUMN_COUNT: 20,\r\n      isRunning: false,\r\n      isStartNode: false,\r\n      isFinishNode: false,\r\n      isWallNode: false, // xxxxxxx\r\n      currRow: 0,\r\n      currCol: 0,\r\n      isDesktopView: true,\r\n    };\r\n\r\n    this.handleMouseDown = this.handleMouseDown.bind(this);\r\n    this.handleMouseLeave = this.handleMouseLeave.bind(this);\r\n    this.toggleIsRunning = this.toggleIsRunning.bind(this);\r\n  }\r\n\r\n  componentDidMount() {\r\n    const grid = this.getInitialGrid();\r\n    this.setState({grid});\r\n  }\r\n\r\n  toggleIsRunning() {\r\n    this.setState({isRunning: !this.state.isRunning});\r\n  }\r\n\r\n  toggleView() {\r\n    if (!this.state.isRunning) {\r\n      this.clearGrid();\r\n      this.clearWalls();\r\n      const isDesktopView = !this.state.isDesktopView;\r\n      let grid;\r\n      if (isDesktopView) {\r\n        grid = this.getInitialGrid(\r\n          this.state.ROW_COUNT,\r\n          this.state.COLUMN_COUNT,\r\n        );\r\n        this.setState({isDesktopView, grid});\r\n      } else {\r\n        if (\r\n          this.state.START_NODE_ROW > this.state.MOBILE_ROW_COUNT ||\r\n          this.state.FINISH_NODE_ROW > this.state.MOBILE_ROW_COUNT ||\r\n          this.state.START_NODE_COL > this.state.MOBILE_COLUMN_COUNT ||\r\n          this.state.FINISH_NODE_COL > this.state.MOBILE_COLUMN_COUNT\r\n        ) {\r\n          alert('Start & Finish Nodes Must Be within 10 Rows x 20 Columns');\r\n        } else {\r\n          grid = this.getInitialGrid(\r\n            this.state.MOBILE_ROW_COUNT,\r\n            this.state.MOBILE_COLUMN_COUNT,\r\n          );\r\n          this.setState({isDesktopView, grid});\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /******************** Set up the initial grid ********************/\r\n  getInitialGrid = (\r\n    rowCount = this.state.ROW_COUNT,\r\n    colCount = this.state.COLUMN_COUNT,\r\n  ) => {\r\n    const initialGrid = [];\r\n    for (let row = 0; row < rowCount; row++) {\r\n      const currentRow = [];\r\n      for (let col = 0; col < colCount; col++) {\r\n        currentRow.push(this.createNode(row, col));\r\n      }\r\n      initialGrid.push(currentRow);\r\n    }\r\n    return initialGrid;\r\n  };\r\n\r\n  createNode = (row, col) => {\r\n    return {\r\n      row,\r\n      col,\r\n      isStart:\r\n        row === this.state.START_NODE_ROW && col === this.state.START_NODE_COL,\r\n      isFinish:\r\n        row === this.state.FINISH_NODE_ROW &&\r\n        col === this.state.FINISH_NODE_COL,\r\n      distance: Infinity,\r\n      distanceToFinishNode:\r\n        Math.abs(this.state.FINISH_NODE_ROW - row) +\r\n        Math.abs(this.state.FINISH_NODE_COL - col),\r\n      isVisited: false,\r\n      isWall: false,\r\n      previousNode: null,\r\n      isNode: true,\r\n    };\r\n  };\r\n\r\n  /******************** Control mouse events ********************/\r\n  handleMouseDown(row, col) {\r\n    if (!this.state.isRunning) {\r\n      if (this.isGridClear()) {\r\n        if (\r\n          document.getElementById(`node-${row}-${col}`).className ===\r\n          'node node-start'\r\n        ) {\r\n          this.setState({\r\n            mouseIsPressed: true,\r\n            isStartNode: true,\r\n            currRow: row,\r\n            currCol: col,\r\n          });\r\n        } else if (\r\n          document.getElementById(`node-${row}-${col}`).className ===\r\n          'node node-finish'\r\n        ) {\r\n          this.setState({\r\n            mouseIsPressed: true,\r\n            isFinishNode: true,\r\n            currRow: row,\r\n            currCol: col,\r\n          });\r\n        } else {\r\n          const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\r\n          this.setState({\r\n            grid: newGrid,\r\n            mouseIsPressed: true,\r\n            isWallNode: true,\r\n            currRow: row,\r\n            currCol: col,\r\n          });\r\n        }\r\n      } else {\r\n        this.clearGrid();\r\n      }\r\n    }\r\n  }\r\n\r\n  isGridClear() {\r\n    for (const row of this.state.grid) {\r\n      for (const node of row) {\r\n        const nodeClassName = document.getElementById(\r\n          `node-${node.row}-${node.col}`,\r\n        ).className;\r\n        if (\r\n          nodeClassName === 'node node-visited' ||\r\n          nodeClassName === 'node node-shortest-path'\r\n        ) {\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n\r\n  handleMouseEnter(row, col) {\r\n    if (!this.state.isRunning) {\r\n      if (this.state.mouseIsPressed) {\r\n        const nodeClassName = document.getElementById(`node-${row}-${col}`)\r\n          .className;\r\n        if (this.state.isStartNode) {\r\n          if (nodeClassName !== 'node node-wall') {\r\n            const prevStartNode = this.state.grid[this.state.currRow][\r\n              this.state.currCol\r\n            ];\r\n            prevStartNode.isStart = false;\r\n            document.getElementById(\r\n              `node-${this.state.currRow}-${this.state.currCol}`,\r\n            ).className = 'node';\r\n\r\n            this.setState({currRow: row, currCol: col});\r\n            const currStartNode = this.state.grid[row][col];\r\n            currStartNode.isStart = true;\r\n            document.getElementById(`node-${row}-${col}`).className =\r\n              'node node-start';\r\n          }\r\n          this.setState({START_NODE_ROW: row, START_NODE_COL: col});\r\n        } else if (this.state.isFinishNode) {\r\n          if (nodeClassName !== 'node node-wall') {\r\n            const prevFinishNode = this.state.grid[this.state.currRow][\r\n              this.state.currCol\r\n            ];\r\n            prevFinishNode.isFinish = false;\r\n            document.getElementById(\r\n              `node-${this.state.currRow}-${this.state.currCol}`,\r\n            ).className = 'node';\r\n\r\n            this.setState({currRow: row, currCol: col});\r\n            const currFinishNode = this.state.grid[row][col];\r\n            currFinishNode.isFinish = true;\r\n            document.getElementById(`node-${row}-${col}`).className =\r\n              'node node-finish';\r\n          }\r\n          this.setState({FINISH_NODE_ROW: row, FINISH_NODE_COL: col});\r\n        } else if (this.state.isWallNode) {\r\n          const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\r\n          this.setState({grid: newGrid});\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  handleMouseUp(row, col) {\r\n    if (!this.state.isRunning) {\r\n      this.setState({mouseIsPressed: false});\r\n      if (this.state.isStartNode) {\r\n        const isStartNode = !this.state.isStartNode;\r\n        this.setState({isStartNode, START_NODE_ROW: row, START_NODE_COL: col});\r\n      } else if (this.state.isFinishNode) {\r\n        const isFinishNode = !this.state.isFinishNode;\r\n        this.setState({\r\n          isFinishNode,\r\n          FINISH_NODE_ROW: row,\r\n          FINISH_NODE_COL: col,\r\n        });\r\n      }\r\n      this.getInitialGrid();\r\n    }\r\n  }\r\n\r\n  handleMouseLeave() {\r\n    if (this.state.isStartNode) {\r\n      const isStartNode = !this.state.isStartNode;\r\n      this.setState({isStartNode, mouseIsPressed: false});\r\n    } else if (this.state.isFinishNode) {\r\n      const isFinishNode = !this.state.isFinishNode;\r\n      this.setState({isFinishNode, mouseIsPressed: false});\r\n    } else if (this.state.isWallNode) {\r\n      const isWallNode = !this.state.isWallNode;\r\n      this.setState({isWallNode, mouseIsPressed: false});\r\n      this.getInitialGrid();\r\n    }\r\n  }\r\n\r\n  /******************** Clear Board/Walls ********************/\r\n\r\n  clearGrid() {\r\n    if (!this.state.isRunning) {\r\n      const newGrid = this.state.grid.slice();\r\n      for (const row of newGrid) {\r\n        for (const node of row) {\r\n          let nodeClassName = document.getElementById(\r\n            `node-${node.row}-${node.col}`,\r\n          ).className;\r\n          if (\r\n            nodeClassName !== 'node node-start' &&\r\n            nodeClassName !== 'node node-finish' &&\r\n            nodeClassName !== 'node node-wall'\r\n          ) {\r\n            document.getElementById(`node-${node.row}-${node.col}`).className =\r\n              'node';\r\n            node.isVisited = false;\r\n            node.distance = Infinity;\r\n            node.distanceToFinishNode =\r\n              Math.abs(this.state.FINISH_NODE_ROW - node.row) +\r\n              Math.abs(this.state.FINISH_NODE_COL - node.col);\r\n          }\r\n          if (nodeClassName === 'node node-finish') {\r\n            node.isVisited = false;\r\n            node.distance = Infinity;\r\n            node.distanceToFinishNode = 0;\r\n          }\r\n          if (nodeClassName === 'node node-start') {\r\n            node.isVisited = false;\r\n            node.distance = Infinity;\r\n            node.distanceToFinishNode =\r\n              Math.abs(this.state.FINISH_NODE_ROW - node.row) +\r\n              Math.abs(this.state.FINISH_NODE_COL - node.col);\r\n            node.isStart = true;\r\n            node.isWall = false;\r\n            node.previousNode = null;\r\n            node.isNode = true;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  clearWalls() {\r\n    if (!this.state.isRunning) {\r\n      const newGrid = this.state.grid.slice();\r\n      for (const row of newGrid) {\r\n        for (const node of row) {\r\n          let nodeClassName = document.getElementById(\r\n            `node-${node.row}-${node.col}`,\r\n          ).className;\r\n          if (nodeClassName === 'node node-wall') {\r\n            document.getElementById(`node-${node.row}-${node.col}`).className =\r\n              'node';\r\n            node.isWall = false;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /******************** Create Animations ********************/\r\n  visualize(algo) {\r\n    if (!this.state.isRunning) {\r\n      this.clearGrid();\r\n      this.toggleIsRunning();\r\n      const {grid} = this.state;\r\n      const startNode =\r\n        grid[this.state.START_NODE_ROW][this.state.START_NODE_COL];\r\n      const finishNode =\r\n        grid[this.state.FINISH_NODE_ROW][this.state.FINISH_NODE_COL];\r\n      let visitedNodesInOrder;\r\n      switch (algo) {\r\n        case 'Dijkstra':\r\n          visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\r\n          break;\r\n        case 'BFS':\r\n          visitedNodesInOrder = bfs(grid, startNode, finishNode);\r\n          break;\r\n        case 'DFS':\r\n          visitedNodesInOrder = dfs(grid, startNode, finishNode);\r\n          break;\r\n        default:\r\n          // should never get here\r\n          break;\r\n      }\r\n      const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\r\n      nodesInShortestPathOrder.push('end');\r\n      this.animate(visitedNodesInOrder, nodesInShortestPathOrder);\r\n    }\r\n  }\r\n\r\n  animate(visitedNodesInOrder, nodesInShortestPathOrder) {\r\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\r\n      if (i === visitedNodesInOrder.length) {\r\n        setTimeout(() => {\r\n          this.animateShortestPath(nodesInShortestPathOrder);\r\n        }, 10 * i);\r\n        return;\r\n      }\r\n      setTimeout(() => {\r\n        const node = visitedNodesInOrder[i];\r\n        const nodeClassName = document.getElementById(\r\n          `node-${node.row}-${node.col}`,\r\n        ).className;\r\n        if (\r\n          nodeClassName !== 'node node-start' &&\r\n          nodeClassName !== 'node node-finish'\r\n        ) {\r\n          document.getElementById(`node-${node.row}-${node.col}`).className =\r\n            'node node-visited';\r\n        }\r\n      }, 10 * i);\r\n    }\r\n  }\r\n\r\n  /******************** Create path from start to finish ********************/\r\n  animateShortestPath(nodesInShortestPathOrder) {\r\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\r\n      if (nodesInShortestPathOrder[i] === 'end') {\r\n        setTimeout(() => {\r\n          this.toggleIsRunning();\r\n        }, i * 50);\r\n      } else {\r\n        setTimeout(() => {\r\n          const node = nodesInShortestPathOrder[i];\r\n          const nodeClassName = document.getElementById(\r\n            `node-${node.row}-${node.col}`,\r\n          ).className;\r\n          if (\r\n            nodeClassName !== 'node node-start' &&\r\n            nodeClassName !== 'node node-finish'\r\n          ) {\r\n            document.getElementById(`node-${node.row}-${node.col}`).className =\r\n              'node node-shortest-path';\r\n          }\r\n        }, i * 40);\r\n      }\r\n    }\r\n  }\r\n\r\n  render() {\r\n    const {grid, mouseIsPressed} = this.state;\r\n    return (\r\n      <div>\r\n        <nav className=\"App-header-3\">\r\n          <div className = \"heading\">\r\n            <h2>Path Finding Visualizer</h2>\r\n          </div>\r\n          <div className = \"button\" onClick={() => this.clearGrid()}> Clear Grid </div>\r\n        <div className = \"button\" onClick={() => this.clearWalls()}> Clear Walls </div>\r\n        <div className = \"button\" onClick={() => this.visualize('Dijkstra')}> Dijkstra Algorithm </div>\r\n        <div className = \"button\" onClick={() => this.visualize('BFS')}> BFS Algorithm </div>\r\n        <div className = \"button\" onClick={() => this.visualize('DFS')}> DFS Algorithm </div>\r\n        </nav>\r\n        <table\r\n          className=\"grid-container\"\r\n          onMouseLeave={() => this.handleMouseLeave()}>\r\n          <tbody className=\"grid\">\r\n            {grid.map((row, rowIdx) => {\r\n              return (\r\n                <tr key={rowIdx}>\r\n                  {row.map((node, nodeIdx) => {\r\n                    const {row, col, isFinish, isStart, isWall} = node;\r\n                    return (\r\n                      <Node\r\n                        key={nodeIdx}\r\n                        col={col}\r\n                        isFinish={isFinish}\r\n                        isStart={isStart}\r\n                        isWall={isWall}\r\n                        mouseIsPressed={mouseIsPressed}\r\n                        onMouseDown={(row, col) =>\r\n                          this.handleMouseDown(row, col)\r\n                        }\r\n                        onMouseEnter={(row, col) =>\r\n                          this.handleMouseEnter(row, col)\r\n                        }\r\n                        onMouseUp={() => this.handleMouseUp(row, col)}\r\n                        row={row}></Node>\r\n                    );\r\n                  })}\r\n                </tr>\r\n              );\r\n            })}\r\n          </tbody>\r\n        </table>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\n/******************** Create Walls ********************/\r\nconst getNewGridWithWallToggled = (grid, row, col) => {\r\n  // mouseDown starts to act strange if I don't make newGrid and work off of grid instead.\r\n  const newGrid = grid.slice();\r\n  const node = newGrid[row][col];\r\n  if (!node.isStart && !node.isFinish && node.isNode) {\r\n    const newNode = {\r\n      ...node,\r\n      isWall: !node.isWall,\r\n    };\r\n    newGrid[row][col] = newNode;\r\n  }\r\n  return newGrid;\r\n};\r\n\r\n// Backtracks from the finishNode to find the shortest path.\r\n// Only works when called after the pathfinding methods.\r\nfunction getNodesInShortestPathOrder(finishNode) {\r\n  const nodesInShortestPathOrder = [];\r\n  let currentNode = finishNode;\r\n  while (currentNode !== null) {\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n  return nodesInShortestPathOrder;\r\n}\r\n","// Returns all nodes in the order in which they were visited.\r\n// Make nodes point back to their previous node so that we can compute the shortest path\r\n// by backtracking from the finish node.\r\n\r\nexport function bfs(grid, startNode, finishNode) {\r\n  const visitedNodesInOrder = [];\r\n  let nextNodesStack = [startNode];\r\n  while (nextNodesStack.length) {\r\n    const currentNode = nextNodesStack.shift();\r\n    if (currentNode === finishNode) return visitedNodesInOrder;\r\n\r\n    if (\r\n      !currentNode.isWall &&\r\n      (currentNode.isStart || !currentNode.isVisited)\r\n    ) {\r\n      currentNode.isVisited = true;\r\n      visitedNodesInOrder.push(currentNode);\r\n      const {col, row} = currentNode;\r\n      let nextNode;\r\n      if (row > 0) {\r\n        nextNode = grid[row - 1][col];\r\n        if (!nextNode.isVisited) {\r\n          nextNode.previousNode = currentNode;\r\n          nextNodesStack.push(nextNode);\r\n        }\r\n      }\r\n      if (row < grid.length - 1) {\r\n        nextNode = grid[row + 1][col];\r\n        if (!nextNode.isVisited) {\r\n          nextNode.previousNode = currentNode;\r\n          nextNodesStack.push(nextNode);\r\n        }\r\n      }\r\n      if (col > 0) {\r\n        nextNode = grid[row][col - 1];\r\n        if (!nextNode.isVisited) {\r\n          nextNode.previousNode = currentNode;\r\n          nextNodesStack.push(nextNode);\r\n        }\r\n      }\r\n      if (col < grid[0].length - 1) {\r\n        nextNode = grid[row][col + 1];\r\n        if (!nextNode.isVisited) {\r\n          nextNode.previousNode = currentNode;\r\n          nextNodesStack.push(nextNode);\r\n        }\r\n      }\r\n    }\r\n  }\r\n  // return visitedNodesInOrder;\r\n}\r\n","// Returns all nodes in the order in which they were visited.\r\n// Make nodes point back to their previous node so that we can compute the shortest path\r\n// by backtracking from the finish node.\r\n\r\nexport function dfs(grid, startNode, finishNode) {\r\n  const visitedNodesInOrder = [];\r\n  const nextNodesStack = [];\r\n  nextNodesStack.push(startNode);\r\n  while (nextNodesStack.length) {\r\n    const currentNode = nextNodesStack.pop();\r\n\r\n    if (currentNode === finishNode) {\r\n      return visitedNodesInOrder;\r\n    }\r\n\r\n    if (\r\n      !currentNode.isWall &&\r\n      (currentNode.isStart || !currentNode.isVisited)\r\n    ) {\r\n      currentNode.isVisited = true;\r\n      visitedNodesInOrder.push(currentNode);\r\n\r\n      const {col, row} = currentNode;\r\n      let nextNode;\r\n      if (row > 0) {\r\n        nextNode = grid[row - 1][col];\r\n        if (!nextNode.isVisited) {\r\n          nextNode.previousNode = currentNode;\r\n          nextNodesStack.push(nextNode);\r\n        }\r\n      }\r\n      if (row < grid.length - 1) {\r\n        nextNode = grid[row + 1][col];\r\n        if (!nextNode.isVisited) {\r\n          nextNode.previousNode = currentNode;\r\n          nextNodesStack.push(nextNode);\r\n        }\r\n      }\r\n      if (col > 0) {\r\n        nextNode = grid[row][col - 1];\r\n        if (!nextNode.isVisited) {\r\n          nextNode.previousNode = currentNode;\r\n          nextNodesStack.push(nextNode);\r\n        }\r\n      }\r\n      if (col < grid[0].length - 1) {\r\n        nextNode = grid[row][col + 1];\r\n        if (!nextNode.isVisited) {\r\n          nextNode.previousNode = currentNode;\r\n          nextNodesStack.push(nextNode);\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n","import React from 'react';\nimport SortingVisualizer from './SortingVisualizer/SortingVisualizer';\nimport SearchingVisualizer from './SearchingVisualizer/SearchingVisualizer';\nimport PathfindingVisualizer from './PathfindingVisualizer/PathfindingVisualizer';\nimport './App.css';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <div>\n        <SortingVisualizer></SortingVisualizer>\n      </div>\n      <div>\n        <SearchingVisualizer></SearchingVisualizer>\n      </div>\n      <div>\n        <PathfindingVisualizer></PathfindingVisualizer>\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}